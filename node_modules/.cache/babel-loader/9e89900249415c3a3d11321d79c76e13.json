{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\Desktop\\\\test\\\\pixori-mint-test\\\\src\\\\clusters\\\\mint-cluster.js\";\nimport React from \"react\";\nimport * as fcl from \"@onflow/fcl\";\nimport * as t from \"@onflow/types\";\nimport { SHA3 } from 'sha3';\nimport * as Elliptic from 'elliptic';\nconst ec = new Elliptic.ec('p256');\n\nfunction hashMsgHex(msgHex) {\n  const sha = new SHA3(256);\n  sha.update(Buffer.from(msgHex, 'hex'));\n  return sha.digest();\n}\n\nfunction signWithKey(privateKey, data) {\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, 'hex'));\n  const sig = key.sign(hashMsgHex(data));\n  const n = 32; // half of signature length?\n\n  const r = sig.r.toArrayLike(Buffer, 'be', n);\n  const s = sig.s.toArrayLike(Buffer, 'be', n);\n  return Buffer.concat([r, s]).toString('hex');\n}\n\nexport const buildAuthorization = ({\n  address,\n  keyId,\n  privateKey\n}) => account => ({ ...account,\n  tempId: address,\n  addr: address,\n  keyId: keyId,\n  resolve: null,\n  signingFunction: data => {\n    return {\n      addr: address,\n      keyId: keyId,\n      signature: signWithKey(privateKey, data.message)\n    };\n  }\n});\nconst admin = {\n  address: '05f5f6e2056f588b',\n  publicKey: '2f903857515eb6eb0bbfe6a8e587878e172c728c964914fde02eefe0d23dcf46d766bf9e1e55843c047b1baa132b8d652e77ed5ffae1b1e807c1c9d9ee15ed33',\n  privateKey: 'cfa7ed37cd930acd4f64c843901f276bc66941952b75a7c0e1646a50ec486e22',\n  keyId: 0\n};\n\nasync function handleTransaction(description, args) {\n  try {\n    console.log(description);\n    const transaction = await fcl.send(args);\n    console.log('-->', transaction.transactionId);\n    await fcl.tx(transaction).onceSealed();\n    console.log('OK');\n  } catch (e) {\n    console.log('KO : ', e);\n  }\n}\n\nexport function MintCluster({\n  name\n}) {\n  async function mint() {\n    console.log('Ping...');\n    await fcl.send([fcl.ping()]);\n    console.log('OK');\n    await handleTransaction('Sending transaction...', [fcl.transaction`\n      import Pixori from 0x05f5f6e2056f588b \n\n      transaction(metadata: {String: String}) {\n      \n          let receiverRef: &{Pixori.NFTReceiver}\n          let minterRef: &Pixori.NFTMinter\n      \n          prepare(acct: AuthAccount) {\n      \n              self.receiverRef = acct.getCapability<&{Pixori.NFTReceiver}>(/public/NFTReceiver)\n                  .borrow()\n                  ?? panic(\"Could not borrow receiver reference\")\n              \n              self.minterRef = acct.borrow<&Pixori.NFTMinter>(from: /storage/NFTMinter)\n                  ?? panic(\"Could not borrow minter reference\")\n          }\n      \n          execute {\n      \n              let newNFT <- self.minterRef.mintNFT()\n              \n              self.receiverRef.deposit(token: <-newNFT, metadata: metadata)\n              log(\"NFT Minted and deposited to the Current user's Collection\")\n          }\n      }\n    `, fcl.payer(buildAuthorization(admin)), fcl.proposer(buildAuthorization(admin)), fcl.authorizations([buildAuthorization(admin)]), fcl.args([fcl.arg([{\n      key: \"name\",\n      value: name\n    }, {\n      key: \"color\",\n      value: \"array\"\n    }], t.Dictionary([{\n      key: t.String,\n      value: t.String\n    }, {\n      key: t.String,\n      value: t.String\n    }]))]), fcl.limit(35)]);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    onClick: mint,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 5\n    }\n  }, \"Mint\"));\n}","map":{"version":3,"sources":["C:/Users/ASUS/Desktop/test/pixori-mint-test/src/clusters/mint-cluster.js"],"names":["React","fcl","t","SHA3","Elliptic","ec","hashMsgHex","msgHex","sha","update","Buffer","from","digest","signWithKey","privateKey","data","key","keyFromPrivate","sig","sign","n","r","toArrayLike","s","concat","toString","buildAuthorization","address","keyId","account","tempId","addr","resolve","signingFunction","signature","message","admin","publicKey","handleTransaction","description","args","console","log","transaction","send","transactionId","tx","onceSealed","e","MintCluster","name","mint","ping","payer","proposer","authorizations","arg","value","Dictionary","String","limit"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport * as fcl from \"@onflow/fcl\";\r\nimport * as t from \"@onflow/types\"\r\nimport { SHA3 } from 'sha3';\r\nimport * as Elliptic from 'elliptic';\r\n\r\n\r\nconst ec = new Elliptic.ec('p256');\r\n\r\nfunction hashMsgHex(msgHex: string) {\r\n  const sha = new SHA3(256);\r\n  sha.update(Buffer.from(msgHex, 'hex'));\r\n  return sha.digest();\r\n}\r\n\r\nfunction signWithKey(privateKey: string, data: string) {\r\n  const key = ec.keyFromPrivate(Buffer.from(privateKey, 'hex'));\r\n  const sig = key.sign(hashMsgHex(data));\r\n  const n = 32; // half of signature length?\r\n  const r = sig.r.toArrayLike(Buffer, 'be', n);\r\n  const s = sig.s.toArrayLike(Buffer, 'be', n);\r\n  return Buffer.concat([r, s]).toString('hex');\r\n}\r\n\r\ninterface Account {\r\n  address: string;\r\n  publicKey: string;\r\n  privateKey: string;\r\n  keyId: number;\r\n}\r\n\r\nexport const buildAuthorization = ({ address, keyId, privateKey }: Account) => (\r\n  account: any\r\n) => ({\r\n  ...account,\r\n  tempId: address,\r\n  addr: address,\r\n  keyId: keyId,\r\n  resolve: null,\r\n  signingFunction: (data: any) => {\r\n    return {\r\n      addr: address,\r\n      keyId: keyId,\r\n      signature: signWithKey(privateKey, data.message),\r\n    };\r\n  },\r\n});\r\n\r\nconst admin: Account = {\r\n  address: '05f5f6e2056f588b',\r\n  publicKey:\r\n    '2f903857515eb6eb0bbfe6a8e587878e172c728c964914fde02eefe0d23dcf46d766bf9e1e55843c047b1baa132b8d652e77ed5ffae1b1e807c1c9d9ee15ed33',\r\n  privateKey:\r\n    'cfa7ed37cd930acd4f64c843901f276bc66941952b75a7c0e1646a50ec486e22',\r\n  keyId: 0,\r\n};\r\n\r\nasync function handleTransaction(description: string, args: any) {\r\n  try {\r\n    console.log(description);\r\n    const transaction = await fcl.send(args);\r\n    console.log('-->', transaction.transactionId);\r\n    await fcl.tx(transaction).onceSealed();\r\n    console.log('OK');\r\n  } catch (e) {\r\n    console.log('KO : ', e);\r\n  }\r\n}\r\n\r\nexport function MintCluster({name}){\r\nasync function mint() {\r\n  console.log('Ping...');\r\n  await fcl.send([fcl.ping()]);\r\n  console.log('OK');\r\n\r\n  await handleTransaction('Sending transaction...', [\r\n      fcl.transaction`\r\n      import Pixori from 0x05f5f6e2056f588b \r\n\r\n      transaction(metadata: {String: String}) {\r\n      \r\n          let receiverRef: &{Pixori.NFTReceiver}\r\n          let minterRef: &Pixori.NFTMinter\r\n      \r\n          prepare(acct: AuthAccount) {\r\n      \r\n              self.receiverRef = acct.getCapability<&{Pixori.NFTReceiver}>(/public/NFTReceiver)\r\n                  .borrow()\r\n                  ?? panic(\"Could not borrow receiver reference\")\r\n              \r\n              self.minterRef = acct.borrow<&Pixori.NFTMinter>(from: /storage/NFTMinter)\r\n                  ?? panic(\"Could not borrow minter reference\")\r\n          }\r\n      \r\n          execute {\r\n      \r\n              let newNFT <- self.minterRef.mintNFT()\r\n              \r\n              self.receiverRef.deposit(token: <-newNFT, metadata: metadata)\r\n              log(\"NFT Minted and deposited to the Current user's Collection\")\r\n          }\r\n      }\r\n    `,\r\n    fcl.payer(buildAuthorization(admin)),\r\n    fcl.proposer(buildAuthorization(admin)),\r\n    fcl.authorizations([buildAuthorization(admin)]),\r\n    fcl.args([\r\n      fcl.arg(\r\n      [\r\n        {key: \"name\", value: name},\r\n        {key: \"color\", value: \"array\"},\r\n      ],  \r\n      t.Dictionary([\r\n        {key: t.String, value: t.String},\r\n        {key: t.String, value: t.String},\r\n      ])\r\n      )]      \r\n    ),\r\n    fcl.limit(35),\r\n  ]);\r\n\r\n}\r\nreturn (\r\n  <div>\r\n    <button onClick={mint}>Mint</button>\r\n  </div>\r\n);\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}